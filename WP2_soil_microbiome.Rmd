---
title: "Run4 NXTGNT"
author: "Lisa Joos and Shira Houwenhuyse"
date: "November 13, 2025"
output:
  html_document:
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_float: yes
    toc_depth: 4
  word_document:
    toc: yes
  pdf_document:
    toc: yes
subtitle: First data exploration of the bacterial data
---

# INFORMATION

For the MiCoS project, 240 fields were sampled throughout Belgium, the Netherlands, and Luxembourg. On those fields 5 replicates (ABCDE) were collected and stored for DNA extraction and eventualy Illumina sequencing. 

Within this dataset the bacterial data were analysed using NextGhent, after troubles with the sequencing provider of ADMERA. The complete dataset contains sequencing data from 7 pools.

| **POOL** | **Description** |
|-----------|----------------|
| POOL1     | BACTERIA       |
| POOL2     | BACTERIA       |
| POOL3     | BACTERIA       |
| POOL4     | BACTERIA       |
| POOL5     | BACTERIA       |
| POOL6     | BACTERIA       |
| POOL7     | NOT MICOS      |



```{r, include = FALSE, message = FALSE, warning = FALSE}
# Load packages
# Data manipulation
library(plyr)
library(dplyr)
library(formattable)
library(multcomp)
library(tidyr)

# phyloseq
library(phyloseq)
library(speedyseq) # for faster processing of phyloseq codes
library(tidyverse)
library(Biostrings)

# Plots
library(ggplot2)

# data
library(vegan)
library(limma)
library(emmeans)

```

# DATA STEP

## Loading data

Load the metadata file and count table. 

- *df* stands for dataframe

```{r}
# Read in files
df_metadata <- read.csv("Metadata_RUN4_NXTGNT_2.csv", sep = ";", header = TRUE)
df_counts <- read.csv("run4_pool1-7_counttable.csv", sep = ";", header = TRUE)
```

As this is a large object, the environment has also been saved and can be reloaded to work from. 
```{r}
#save.image(file = "metadata_counts.Rdata")
load("metadata_counts.Rdata")
```


```{r}
head(df_metadata)
head(df_counts)
df_counts[ , (ncol(df_counts) - 19) : ncol(df_counts)]

```

## Cleaning data


### Remove unwanted ASVs
```{r}
# Clean-up data by removing unwanted sequences
df_counts <- df_counts[!df_counts$Family %in% "Mitochondria",] #234474
df_counts <- df_counts[!df_counts$Order %in% "Chloroplast",] #233505
df_counts <- df_counts[!df_counts$Order %in% "Rickettsiales",] #232325
df_counts <- df_counts[!df_counts$Kingdom %in% "Eukaryota",] #232311
```


Only MC24_237_G is empty. 

```{r}
write.csv(colnames(df_counts), "colnames.csv", sep = ";")
```


```{r}
identical(df_counts$MC24_002_E.1, df_counts$MC24_002_E)
```
Within the df_counts there are multiple samples that are double, the doubles have a .1 at the end.

# PHYLOSEQ 

```{r}
# Checks before creating a phyloseq object
## Are the rownames of the metadata the same as counts colnames
sum(sample_cols %in% rownames(df_metadata))

## Missing samples that are present in the countdata and not in the df_metadata
missing_samples <- sample_cols[ ! sample_cols %in% rownames(df_metadata) ]
missing_samples

missing_samples <- rownames(df_metadata)[ ! rownames(df_metadata) %in% sample_cols ]
missing_samples

df_metadata[df_metadata$SampleID %in% missing_samples,]

missing_samples %in% df_metadata[df_metadata$Pool == "POOL2",]$SampleID

df_metadata[df_metadata$Pool == "POOL2",]$SampleID %in% missing_samples
```
All the samplesnames with a ".1" at the end are doubles. These are exactly the same as the samples without the .1 so can be confidently removed.

However, the samples called NC_extraction_2a, NC_extraction_2b and NC_extraction_2C should be added to the metadatafile. 
- DONE


```{r}
rownames(df_metadata) <- df_metadata$SampleID

# ---- Identify sample vs taxonomy columns automatically ----
# List of taxonomy column names
tax_cols <- c("Kingdom","Phylum","Class","Order","Family","Genus","Species")

# Remove non-sample columns (seq, ASV, total, taxonomy columns)
sample_cols <- setdiff(colnames(df_counts), c("seq","ASV","total", tax_cols)) # In total 1266 samplenames

# ---- Build the objects ----
# OTU table
otu_mat <- as.matrix(df_counts[, sample_cols])
rownames(otu_mat) <- df_counts$ASV
OTU <- otu_table(otu_mat, taxa_are_rows = TRUE)

# Taxonomy table
tax_mat <- as.matrix(df_counts[, tax_cols])
rownames(tax_mat) <- df_counts$ASV
TAX <- tax_table(tax_mat)

# Metadata
SAM <- sample_data(df_metadata)

# ---- Build phyloseq object ----
ps <- phyloseq(OTU, TAX, SAM)

# ---- Subset samples if needed ----
# e.g., only those with Comparison == "Yes"
psB <- subset_samples(ps, Responsible == "Micos")
ps_mock <- subset_samples(ps, Responsible == "Shira")
```
In total, 1266 samples exists in the df_counts. However there are double names. In the metadata 1255 samples exists so there is already a discrepancy

As the counttable is big and takes a long while to reload, it is possible to save the phyloseq object as well and start from there.

### Remove not-micos samples

Within this dataset we have samples from Lisa Slachmulyders and Shira. Those should be removed
```{r, include = FALSE}
psB <- subset_samples(psB, Responsible %in% c("Micos", "NC"))
```


### Remove empty samples 

Some samples have zero counts and should be removed.

```{r}
zero_cols <- df_counts %>% 
  
  # Only select values that are numeric (eg not sequences)
  select_if(is.numeric) %>%
  # Take the sum of each column
  summarise(across(everything(), ~sum(.x, na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "col", values_to = "sum") %>%
  filter(sum == 0) %>%
  pull(col)

zero_cols
```

```{r}
saveRDS(psB, file = "phyloseq_object_bacteria_micos.rds")

# Reload object
#psB <- readRDS("phyloseq_object_bacteria_micos.rds")
```


## Remove data

Pool 7 is not related to the MiCoS research and will be removed from any downstream analysis. 

```{r, include = FALSE}
#psB <- subset_samples(psB, Pool != "POOL7")
```

## Technical filtering
Normally a filtering of at least 2 counts in at least 3 (at random samples) should be applied. 
```{r}
# Technical filtering of the data 
psB <- filter_taxa(psB, function(x) sum(x >= 2) >= 3, TRUE)
```

After filtering of at least 2 counts in three replicates, a total of 75543 taxa are found.

```{r}
# Technical filtering of the data 
psB <- filter_taxa(psB, function(x) sum(x) > 0, prune = TRUE) 
```

```{r}
otu_table(psB) / 
```

# DATA EXPLORATION

## Library depth

Make sure that all samples are selected using [2:105]

```{r}
lib_depth <- sample_sums(psB)
head(lib_depth)

#Info over de dataset
min(lib_depth) 
max(lib_depth)
mean(lib_depth)
sum(lib_depth)


```

```{r}
# Calculate the total library size for each sample
df_lib_depth <- df_metadata %>%
  mutate(
    Library_depth = t(colSums(df_counts[2:105])),
    sampleID = t(colnames(df_counts[2:105]))
  )
```

```{r}
#Add library depth to metadata
sample_data(psB)$LibraryDepth <- sample_sums(psB)

#plot
hist(sample_data(psB)$LibraryDepth, breaks = 30,
     main = "Library Depth Distribution",
     xlab = "Reads per Sample")

```

```{r}
# Create a ggplot
ggplot(data = sample_data(psB), aes(x = Pool, y = LibraryDepth)) + 
  geom_boxplot() +
  geom_jitter(shape = 8, position = position_jitter(0.2)) +
  ggtitle("Library depth for each pool")
```


## Barplot

Logic order

- Step 1: Treatment filtering (in our case on pool level) using subset_samples
- Step 2: tax_glom on the level you want
- Step 3: create relative abundances

```{r}
B_phylum_rel <- psB %>% 
 # subset_samples(Pool  c("control", "cancer")) %>% 
  tax_glom("Phylum") %>% 
           transform_sample_counts(function(x){100*x/sum(x)}) %>%
  psmelt()
otu_table(psB)

sum(colSums(otu_table(psB)) == 0)

otu_table(psB)
```
There are 17 empty samples. There are zeroes present in the data for certain ASVs in certain samples. 

### Phylum level

```{r}
# Agglomerate on phylum level
psB_phylum <- tax_glom(psB, taxrank = "Phylum")

# Make the samples relative
psB_phylum_rel <- transform_sample_counts(psB_phylum, function(asv) asv/sum(asv))
otu_table(psB_phylum_rel)
# Melt the dataset
B_phylum_rel <- phyloseq::psmelt(psB_phylum_rel)
```
On phylum level, in total 64 phyla are found back.

#### Pool

```{r}
# Order the phylum based on abundance for ggplot
## Summarize the data to calculate total abundance within each Timepoint and Phylum
ps_summary <- B_phylum_rel %>%
  group_by(Phylum, Pool) %>%
  summarise(Abundance = mean(Abundance)) %>%
  ungroup() %>%
  arrange((Abundance))
```

```{r fig.width = 10, fig.height = 6}
ggplot(ps_summary, aes(x = Pool, y = Abundance, fill = Phylum)) + 
  geom_bar(stat = "identity", position = "stack") +
  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
   scale_y_continuous(labels = scales::percent_format()) +
  
  labs(y = "Relative abundance") 
```




# SHIRA

## Rarefaction
Nanopore: endosphere around 40 000, average around 60 000
PacBio: seedcoat around 500, average around 35 000
Illumina: average around 25 000
=> rarify at 25 000
```{r}
# Rarefy and filter low-depth samples
#SilvaDB
ps_T0_rar <- ps_T0 %>%
  prune_samples(sample_sums(.) > 25000, .) %>%
  rarefy_even_depth(sample.size = min(sample_sums(.)), rngseed = 123, replace = FALSE, verbose = FALSE) %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  filter_taxa(function(x) mean(x) > 1e-5, prune = TRUE)

ps_T1_rar <- ps_T1 %>%
  prune_samples(sample_sums(.) > 25000, .) %>%
  rarefy_even_depth(sample.size = min(sample_sums(.)), rngseed = 123, replace = FALSE, verbose = FALSE) %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  filter_taxa(function(x) mean(x) > 1e-5, prune = TRUE)

```


## Cleaun up of unwanted groups
ps_T0
ps_T1
ps_T0_rar
ps_T1_rar

```{r}
# Clean-up data by removing unwanted sequences from phyloseq
#Niet zeker als ik dit mag doen 
ps0 <- subset_taxa(ps_T0, !is.na(Phylum) & !Phylum %in% c("", "uncharacterized"))
ps0

filterPhyla = c("Chloroplast","Mitochondria", "Eukaryota")
#Filter from:  "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", and "ASV"
ps1_1 <- subset_taxa(ps0, !Kingdom %in% filterPhyla)
ps1_1
ps1_2 <- subset_taxa(ps1_1, !Phylum %in% filterPhyla)
ps1_2
ps1_3 <- subset_taxa(ps1_2, !Class %in% filterPhyla)
ps1_3
ps1_4 <- subset_taxa(ps1_3, !Order %in% filterPhyla)
ps1_4
ps1_5 <- subset_taxa(ps1_4, !Family %in% filterPhyla)
ps1_5
ps1_6 <- subset_taxa(ps1_5, !Genus %in% filterPhyla)
ps1_6


```

## Put best possible ID of the ASV in the name 
```{r}
#name ASV_1_xxx
sa <- ps1_6
 
for (i in 1:ntaxa(sa)){
  if (nchar(tax_table(sa)[i,6], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,6], "_sp.", sep = "")
  }
  else if (nchar(tax_table(sa)[i,5], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,5], sep = "")
  }
  else if (nchar(tax_table(sa)[i,4], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,4], sep = "")
  }
  else if (nchar(tax_table(sa)[i,3], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,3], sep = "")
  }
  else if (nchar(tax_table(sa)[i,2], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,2], sep = "")
  }
  else {
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,1], sep = "")
  }
}

tax_table(sa) <- cbind(tax_table(sa), taxa_names(sa))
colnames(tax_table(sa))[8] <- "ASV"

tax_table(sa)
```



## Barplot with agglomerate

# at phylum level
```{r}
# Agglomerate on phylum level
psB_phylum <- tax_glom(ps1_6, taxrank = "Phylum")

# Make the samples relative
psB_phylum_rel <- transform_sample_counts(psB_phylum, function(sv) sv/sum(sv))

# Melt the dataset
B_phylum_rel <- speedyseq::psmelt(psB_phylum_rel)

#plot
plot_bar(psB_phylum_rel, fill = "Phylum") +
  aes(x = SampleID) +
  facet_grid(cols = vars(Sample_type), scale = "free", space = "free_x") +
  guides(fill = guide_legend(ncol = 2)) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 10),
    legend.position = "right",
    panel.spacing = unit(1, "lines")
  ) +
  labs(x = "Sample", y = "Relative Abundance")
```


```{r}
# Order the phylum based on abundance for ggplot
## Summarize the data to calculate total abundance within each Timepoint and Phylum
ps_summary <- B_phylum_rel %>%
  group_by(Phylum, Responsible) %>%
  summarise(Abundance = mean(Abundance)) %>%
  ungroup() %>%
  arrange((Abundance))
```


```{r}
ggplot(ps_summary, aes(x = Responsible, y = Abundance, fill = Phylum)) + 
  geom_bar(stat = "identity", position = "stack") +
  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
   scale_y_continuous(labels = scales::percent_format()) +
  
  labs(y = "Relative abundance") 

```

## Beta-diversity

```{r}
#BETADIVERSITY ANALYSIS - ORDINATION (here, based on BRAY-CURTIS dissimilarity)

#ordination tout Type Bray}

# Here I make an ordination on the whole data set
# I did it on Bray-Curtis dissimilarity, but it is also possible to do it on the unifrac distance that takes the phylogeny into account

#To throw away empty samples, otherwise summ will nog work
sa_ra <- transform_sample_counts(ps1_6, function(x){ x / sum(x)}) #na.rm = TRUE  
sa_ra_1 <- prune_samples(sample_sums(sa_ra) > 0, sa_ra)

theme_set(theme_bw())
ordu_sa_ra = ordinate(sa_ra_1 , "PCoA", "bray")

#plot
OrdiPlot_sa_ra = plot_ordination(sa_ra_1, ordu_sa_ra, color="Responsible", shape="Responsible")
OrdiPlot_sa_ra + 
  geom_point(size=5, stroke=1.5) + 
  coord_fixed(1/1) + 
  scale_shape_manual(values = c(16, 17, 15, 3, 7, 8, 9, 10, 4)) + 
  theme(
    axis.text = element_text(size=20),
    axis.title = element_text(size=20),
    legend.title = element_text(size=20),
    legend.text = element_text(size=20),
    legend.position = "bottom"
  ) +
  labs(color = "Responsible") +
  guides(color = guide_legend(ncol=2),shape = guide_legend(ncol=2))

OrdiPlot_sa_ra = plot_ordination(sa_ra_1, ordu_sa_ra, color="Country", shape="Responsible")
OrdiPlot_sa_ra + 
  geom_point(size=5, stroke=1.5) + 
  coord_fixed(1/1) + 
  scale_shape_manual(values = c(16, 17, 15, 3, 7, 8, 9, 10, 4)) + 
  theme(
    axis.text = element_text(size=20),
    axis.title = element_text(size=20),
    legend.title = element_text(size=20),
    legend.text = element_text(size=20),
    legend.position = "bottom"
  ) +
  labs(color = "Country", shape="Responsible") +
  guides(color = guide_legend(ncol=2),shape = guide_legend(ncol=2))


OrdiPlot_sa_ra = plot_ordination(sa_ra_1, ordu_sa_ra, color="Soil", shape="Country")
OrdiPlot_sa_ra + 
  geom_point(size=5, stroke=1.5) + 
  coord_fixed(1/1) + 
  scale_shape_manual(values = c(16, 17, 15, 3, 7, 8, 9, 10, 4)) + 
  theme(
    axis.text = element_text(size=20),
    axis.title = element_text(size=20),
    legend.title = element_text(size=20),
    legend.text = element_text(size=20),
    legend.position = "bottom"
  ) +
  labs(color = "Country", shape="Responsible") +
  guides(color = guide_legend(ncol=4),shape = guide_legend(ncol=2))

```
#Interactive beta-diversity
```{r}
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::install(c("phyloseq", "microbiome", "ComplexHeatmap"), update = FALSE)

install.packages(
  "microViz",
  repos = c(davidbarnett = "https://david-barnett.r-universe.dev", getOption("repos"))
)

install.packages("ggtext") # for rotated labels on ord_plot() 
install.packages("ggraph") # for taxatree_plots()
install.packages("DT") # for tax_fix_interactive()
install.packages("corncob") # for beta binomial models in tax_model()

# Installing from GitHub requires the remotes package
install.packages("remotes")
# Windows users will also need to have RTools installed! http://jtleek.com/modules/01_DataScientistToolbox/02_10_rtools/

# To install the latest version:
remotes::install_github("david-barnett/microViz")


library(microViz)

install.packages("shiny")
library(shiny)


```

```{r}
sa_ra <- transform_sample_counts(sa, function(x){ x / sum(x)}) #na.rm = TRUE  
sa_ra_1 <- prune_samples(sample_sums(sa_ra) > 0, sa_ra)

ordu_sa_ra = ordinate(sa_ra_1 , "PCoA", "bray")

ord_explore(sa_ra_1, ordu_sa_ra, colour_by="Responsible")

ord_explore(sa_comparison)
```



##########################################################################################

#Run2 Pool2
```{r, include = FALSE}
# Locate data
path <- ("//files.ugent.be/shouwenh/shares/lm_micro2soil/2_data_analysis/RUN2_counttables/") # FOLDER WHERE RAW DATA IS STORED

```

```{r, include = FALSE}
# Locate data
# Create full pathways to necessary data files
path_tax <- file.path(path, "Run2_Pool2_merged_taxonomy.rds")
path_seqtab <- file.path(path, "Run2_Pool2_merged_seqtab_nochim.rds")
path_metadata <- file.path(path, "Run2_Pool2_metadata.csv") 
path_counts <- file.path(path, "Run2_Pool2_counttable.csv")
#path_tree <- file.path(path, "Comparison_asv_tree.nwk")

## Check if paths exists
file.exists(path_tax, path_seqtab, path_metadata, path_counts)#, path_tree)
```

```{r}
# Read in files
seqtab <- readRDS(path_seqtab)
tax <- readRDS(path_tax)
df_metadata <- read.csv(path_metadata, sep = ";", header = TRUE)
df_counts <- read.csv(path_counts, sep = ";", header = TRUE)
#tree <- read_tree(path_tree)
```


## Phyloseq 
```{r}
rownames(df_metadata) <- df_metadata$SampleID

# Preferred assignment of taxonomy
TaxT <- tax_table(as.matrix(df_counts[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")]))

# Create phyloseq object
# from count table: [2:105]
# 105 = total number of columns - taxonmy columns at the end - "total" column (-9)
ps <- phyloseq(otu_table(df_counts[2:177], taxa_are_rows = TRUE), tax_table(TaxT), sample_data(df_metadata))

#Only select the samples needed for the "comparison"
sample_data(ps)
```


# ALL SAMPLES
## Library depth

Make sure that all samples are selected using [2:105]
```{r}
lib_depth <- sample_sums(ps)
head(lib_depth)

#Add library depth to metadata
sample_data(ps)$LibraryDepth <- sample_sums(ps)

#plot
hist(sample_data(ps)$LibraryDepth, breaks = 30,
     main = "Library Depth Distribution",
     xlab = "Reads per Sample")

#ggplot
ggplot(data = sample_data(ps), aes(x = LibraryDepth, y = Responsible)) + 
  geom_boxplot() +
  geom_jitter(shape = 8, position = position_jitter(0.2)) +
  ggtitle("Library depth of timeseries, seperated on compartments")


```


## Technical filtering
```{r}
# Technical filtering of the data 
ps <- filter_taxa(ps, function(x) sum(x) > 0, prune = TRUE) 
```


Normally a filtering of at least 2 counts in at least 3 (at random samples) should be applied. However, as the quality of the data is not great, this will remove too many reads for the next steps. 

## Make relative
```{r}
# Make relative
psBRel <- speedyseq::transform_sample_counts(psB, function(ASV) ASV/sum(ASV))
```



# SHIRA
## Clean up of unwanted groups
```{r}
# Clean-up data by removing unwanted sequences from phyloseq
#Niet zeker als ik dit mag doen 
ps0 <- subset_taxa(ps, !is.na(Phylum) & !Phylum %in% c("", "uncharacterized"))
ps0

filterPhyla = c("Chloroplast","Mitochondria", "Eukaryota")
#Filter from:  "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", and "ASV"
ps1_1 <- subset_taxa(ps0, !Kingdom %in% filterPhyla)
ps1_1
ps1_2 <- subset_taxa(ps1_1, !Phylum %in% filterPhyla)
ps1_2
ps1_3 <- subset_taxa(ps1_2, !Class %in% filterPhyla)
ps1_3
ps1_4 <- subset_taxa(ps1_3, !Order %in% filterPhyla)
ps1_4
ps1_5 <- subset_taxa(ps1_4, !Family %in% filterPhyla)
ps1_5
ps1_6 <- subset_taxa(ps1_5, !Genus %in% filterPhyla)
ps1_6


```

## Put best possible ID of the ASV in the name 
```{r}
#name ASV_1_xxx
sa <- ps1_6
 
for (i in 1:ntaxa(sa)){
  if (nchar(tax_table(sa)[i,6], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,6], "_sp.", sep = "")
  }
  else if (nchar(tax_table(sa)[i,5], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,5], sep = "")
  }
  else if (nchar(tax_table(sa)[i,4], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,4], sep = "")
  }
  else if (nchar(tax_table(sa)[i,3], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,3], sep = "")
  }
  else if (nchar(tax_table(sa)[i,2], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,2], sep = "")
  }
  else {
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,1], sep = "")
  }
}

tax_table(sa) <- cbind(tax_table(sa), taxa_names(sa))
colnames(tax_table(sa))[8] <- "ASV"

tax_table(sa)
```

## Barplot with agglomerate


```{r}
# Agglomerate on phylum level
psB_phylum <- tax_glom(ps1_6, taxrank = "Phylum")


# Make the samples relative
psB_phylum_rel <- transform_sample_counts(psB_phylum, function(sv) sv/sum(sv))


# Melt the dataset
B_phylum_rel <- speedyseq::psmelt(psB_phylum_rel)



plot_bar(psB_phylum_rel, fill = "Phylum") +
  aes(x = SampleID) +
  facet_grid(cols = vars(Responsible), scale = "free", space = "free_x") +
  guides(fill = guide_legend(ncol = 2)) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 10),
    legend.position = "right",
    panel.spacing = unit(1, "lines")
  ) +
  labs(x = "Sample", y = "Relative Abundance")


```


```{r}
# Order the phylum based on abundance for ggplot
## Summarize the data to calculate total abundance within each Timepoint and Phylum
ps_summary <- B_phylum_rel %>%
  group_by(Phylum, Responsible) %>%
  summarise(Abundance = mean(Abundance)) %>%
  ungroup() %>%
  arrange((Abundance))
```


```{r}
ggplot(ps_summary, aes(x = Responsible, y = Abundance, fill = Phylum)) + 
  geom_bar(stat = "identity", position = "stack") +
  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
   scale_y_continuous(labels = scales::percent_format()) +
  
  labs(y = "Relative abundance") 

```


## Beta-diversity

```{r}
#BETADIVERSITY ANALYSIS - ORDINATION (here, based on BRAY-CURTIS dissimilarity)

#ordination tout Type Bray}

# Here I make an ordination on the whole data set
# I did it on Bray-Curtis dissimilarity, but it is also possible to do it on the unifrac distance that takes the phylogeny into account

#To throw away empty samples, otherwise summ will nog work
sa_ra <- transform_sample_counts(sa, function(x){ x / sum(x)}) #na.rm = TRUE  
sa_ra_1 <- prune_samples(sample_sums(sa_ra) > 0, sa_ra)

theme_set(theme_bw())
ordu_sa_ra = ordinate(sa_ra_1 , "PCoA", "bray")

#plot
OrdiPlot_sa_ra = plot_ordination(sa_ra_1, ordu_sa_ra, color="Responsible",shape="Responsible")
OrdiPlot_sa_ra + 
  geom_point(size=5, stroke=1.5) + 
  coord_fixed(1/1) + 
  scale_shape_manual(values = c(16, 17, 15, 3, 7, 8, 9)) + 
  theme(
    axis.text = element_text(size=20),
    axis.title = element_text(size=20),
    legend.title = element_text(size=20),
    legend.text = element_text(size=20),
    legend.position = "bottom"
  ) +
  labs(color = "Responsible") +
  guides(color = guide_legend(ncol=2),shape = guide_legend(ncol=2))


```



####################################################################################################################################################################################


#Run3 Pool1 and 2
```{r, include = FALSE}
# Locate data
path <- ("//files.ugent.be/shouwenh/shares/lm_micro2soil/2_ASV_counttables/RUN3_counttables/Merged_pools") # FOLDER WHERE RAW DATA IS STORED

```

```{r, include = FALSE}
# Locate data
# Create full pathways to necessary data files
path_tax <- file.path(path, "Run3_Pool1and2_merged_taxonomy.rds")
path_seqtab <- file.path(path, "Run3_Pool1and2_merged_seqtab_nochim.rds")
path_metadata <- file.path(path, "Run3_Pool1and2_metadata_barcodes.csv") 
path_counts <- file.path(path, "Run3_Pool1and2_counttable.csv")
#path_tree <- file.path(path, "Comparison_asv_tree.nwk")

## Check if paths exists
file.exists(path_tax, path_seqtab, path_metadata, path_counts)#, path_tree)
```

```{r}
# Read in files
seqtab <- readRDS(path_seqtab)
tax <- readRDS(path_tax)
df_metadata <- read.csv(path_metadata, sep = ";", header = TRUE)
df_counts <- read.csv(path_counts, sep = ";", header = TRUE)
#tree <- read_tree(path_tree)
```


## Phyloseq 
```{r}
rownames(df_metadata) <- df_metadata$SampleID

# Preferred assignment of taxonomy
TaxT <- tax_table(as.matrix(df_counts[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")]))

# Create phyloseq object
# from count table: [2:105]
# 105 = total number of columns - taxonmy columns at the end - "total" column (-9)
ps <- phyloseq(otu_table(df_counts[2:270], taxa_are_rows = TRUE), tax_table(TaxT), sample_data(df_metadata))

#Only select the samples needed for the "comparison"
sample_data(ps)
```


# ALL SAMPLES
## Library depth

Make sure that all samples are selected using [2:105]
```{r}
lib_depth <- sample_sums(ps)
head(lib_depth)

#Add library depth to metadata
sample_data(ps)$LibraryDepth <- sample_sums(ps)

#plot
hist(sample_data(ps)$LibraryDepth, breaks = 30,
     main = "Library Depth Distribution",
     xlab = "Reads per Sample")

#ggplot
ggplot(data = sample_data(ps), aes(x = LibraryDepth, y = Responsible)) + 
  geom_boxplot() +
  geom_jitter(shape = 8, position = position_jitter(0.2)) +
  ggtitle("Library depth of timeseries, seperated on compartments")


```


## Technical filtering
```{r}
# Technical filtering of the data 
ps <- filter_taxa(ps, function(x) sum(x) > 0, prune = TRUE) 
```


Normally a filtering of at least 2 counts in at least 3 (at random samples) should be applied. However, as the quality of the data is not great, this will remove too many reads for the next steps. 

## Cleaun up of unwanted groups
```{r}
# Clean-up data by removing unwanted sequences from phyloseq
#Niet zeker als ik dit mag doen 
ps0 <- subset_taxa(ps, !is.na(Phylum) & !Phylum %in% c("", "uncharacterized"))
ps0

filterPhyla = c("Chloroplast","Mitochondria", "Eukaryota")
#Filter from:  "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", and "ASV"
ps1_1 <- subset_taxa(ps0, !Kingdom %in% filterPhyla)
ps1_1
ps1_2 <- subset_taxa(ps1_1, !Phylum %in% filterPhyla)
ps1_2
ps1_3 <- subset_taxa(ps1_2, !Class %in% filterPhyla)
ps1_3
ps1_4 <- subset_taxa(ps1_3, !Order %in% filterPhyla)
ps1_4
ps1_5 <- subset_taxa(ps1_4, !Family %in% filterPhyla)
ps1_5
ps1_6 <- subset_taxa(ps1_5, !Genus %in% filterPhyla)
ps1_6


```

## Put best possible ID of the ASV in the name 
```{r}
#name ASV_1_xxx
sa <- ps1_6
 
for (i in 1:ntaxa(sa)){
  if (nchar(tax_table(sa)[i,6], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,6], "_sp.", sep = "")
  }
  else if (nchar(tax_table(sa)[i,5], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,5], sep = "")
  }
  else if (nchar(tax_table(sa)[i,4], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,4], sep = "")
  }
  else if (nchar(tax_table(sa)[i,3], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,3], sep = "")
  }
  else if (nchar(tax_table(sa)[i,2], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,2], sep = "")
  }
  else {
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,1], sep = "")
  }
}

tax_table(sa) <- cbind(tax_table(sa), taxa_names(sa))
colnames(tax_table(sa))[8] <- "ASV"

tax_table(sa)
```

## Barplot with agglomerate


```{r}
# Agglomerate on phylum level
psB_phylum <- tax_glom(ps1_6, taxrank = "Phylum")


# Make the samples relative
psB_phylum_rel <- transform_sample_counts(psB_phylum, function(sv) sv/sum(sv))


# Melt the dataset
B_phylum_rel <- speedyseq::psmelt(psB_phylum_rel)



plot_bar(psB_phylum_rel, fill = "Phylum") +
  aes(x = SampleID) +
  facet_grid(cols = vars(Responsible), scale = "free", space = "free_x") +
  guides(fill = guide_legend(ncol = 2)) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 10),
    legend.position = "right",
    panel.spacing = unit(1, "lines")
  ) +
  labs(x = "Sample", y = "Relative Abundance")


```


```{r}
# Order the phylum based on abundance for ggplot
## Summarize the data to calculate total abundance within each Timepoint and Phylum
ps_summary <- B_phylum_rel %>%
  group_by(Phylum, Responsible) %>%
  summarise(Abundance = mean(Abundance)) %>%
  ungroup() %>%
  arrange((Abundance))
```


```{r}
ggplot(ps_summary, aes(x = Responsible, y = Abundance, fill = Phylum)) + 
  geom_bar(stat = "identity", position = "stack") +
  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
   scale_y_continuous(labels = scales::percent_format()) +
  
  labs(y = "Relative abundance") 

```


## Beta-diversity

```{r}
#BETADIVERSITY ANALYSIS - ORDINATION (here, based on BRAY-CURTIS dissimilarity)

#ordination tout Type Bray}

# Here I make an ordination on the whole data set
# I did it on Bray-Curtis dissimilarity, but it is also possible to do it on the unifrac distance that takes the phylogeny into account

#To throw away empty samples, otherwise summ will nog work
sa_ra <- transform_sample_counts(ps1_6, function(x){ x / sum(x)}) #na.rm = TRUE  
sa_ra_1 <- prune_samples(sample_sums(sa_ra) > 0, sa_ra)

theme_set(theme_bw())
ordu_sa_ra = ordinate(sa_ra_1 , "PCoA", "bray")

#plot
OrdiPlot_sa_ra = plot_ordination(sa_ra_1, ordu_sa_ra, color="Responsible", shape ="Responsible")
OrdiPlot_sa_ra + 
  geom_point(size=5, stroke=1.5) + 
  coord_fixed(1/1) + 
  scale_shape_manual(values = c(16, 17, 15, 3, 7, 8, 9, 10, 4)) + 
  theme(
    axis.text = element_text(size=20),
    axis.title = element_text(size=20),
    legend.title = element_text(size=20),
    legend.text = element_text(size=20),
    legend.position = "bottom"
  ) +
  labs(color = "Responsible") +
  guides(color = guide_legend(ncol=2),shape = guide_legend(ncol=2))

install.packages("ggrepel")
library(ggrepel)

sample_data(sa_ra_1)$Column <- as.factor(sample_data(sa_ra_1)$Column)

OrdiPlot_sa_ra = plot_ordination(sa_ra_1, ordu_sa_ra, color="Column", shape="Plate_sample")
OrdiPlot_sa_ra + 
  geom_point(size=5, stroke=1.5) + 
  geom_text_repel(aes(label = F), size = 5, max.overlaps=100) +  # Add F labels
  coord_fixed(1/1) + 
  #scale_shape_manual(values = c(16, 17, 15, 3, 7, 8, 9, 10, 4)) + 
  theme(
    axis.text = element_text(size=20),
    axis.title = element_text(size=20),
    legend.title = element_text(size=20),
    legend.text = element_text(size=20),
    legend.position = "bottom"
  ) +
  labs(color = "Column", shape ="Plate_sample") +
  guides(color = guide_legend(ncol=6), shape = guide_legend(ncol=1))
```

##########################################################################################


#Run3 Pool3 and 4
```{r, include = FALSE}
# Locate data
path <- ("//files.ugent.be/shouwenh/shares/lm_micro2soil/2_data_analysis/RUN3_counttables/Merged_pools") # FOLDER WHERE RAW DATA IS STORED

```

```{r, include = FALSE}
# Locate data
# Create full pathways to necessary data files
path_tax <- file.path(path, "Run3_Pool3and4_merged_taxonomy.rds")
path_seqtab <- file.path(path, "Run3_Pool3and4_merged_seqtab_nochim.rds")
path_metadata <- file.path(path, "Run3_Pool3and4_metadata.csv") 
path_counts <- file.path(path, "Run3_Pool3and4_counttable.csv")
#path_tree <- file.path(path, "Comparison_asv_tree.nwk")

## Check if paths exists
file.exists(path_tax, path_seqtab, path_metadata, path_counts)#, path_tree)
```

```{r}
# Read in files
seqtab <- readRDS(path_seqtab)
tax <- readRDS(path_tax)
df_metadata <- read.csv(path_metadata, sep = ";", header = TRUE)
df_counts <- read.csv(path_counts, sep = ";", header = TRUE)
#tree <- read_tree(path_tree)
```


## Phyloseq 
```{r}
rownames(df_metadata) <- df_metadata$SampleID

# Preferred assignment of taxonomy
TaxT <- tax_table(as.matrix(df_counts[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")]))

# Create phyloseq object
# from count table: [2:105]
# 105 = total number of columns - taxonmy columns at the end - "total" column (-9)
ps <- phyloseq(otu_table(df_counts[2:245], taxa_are_rows = TRUE), tax_table(TaxT), sample_data(df_metadata))

#Only select the samples needed for the "comparison"
sample_data(ps)
```


# ALL SAMPLES
## Library depth

Make sure that all samples are selected using [2:105]
```{r}
lib_depth <- sample_sums(ps)
head(lib_depth)

#Add library depth to metadata
sample_data(ps)$LibraryDepth <- sample_sums(ps)

#plot
hist(sample_data(ps)$LibraryDepth, breaks = 30,
     main = "Library Depth Distribution",
     xlab = "Reads per Sample")

#ggplot
ggplot(data = sample_data(ps), aes(x = LibraryDepth, y = Responsible)) + 
  geom_boxplot() +
  geom_jitter(shape = 8, position = position_jitter(0.2)) +
  ggtitle("Library depth of timeseries, seperated on compartments")


```


## Technical filtering
```{r}
# Technical filtering of the data 
ps <- filter_taxa(ps, function(x) sum(x) > 0, prune = TRUE) 
```


Normally a filtering of at least 2 counts in at least 3 (at random samples) should be applied. However, as the quality of the data is not great, this will remove too many reads for the next steps. 

## Cleaun up of unwanted groups
```{r}
# Clean-up data by removing unwanted sequences from phyloseq
#Niet zeker als ik dit mag doen 
ps0 <- subset_taxa(ps, !is.na(Phylum) & !Phylum %in% c("", "uncharacterized"))
ps0

filterPhyla = c("Chloroplast","Mitochondria", "Eukaryota")
#Filter from:  "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", and "ASV"
ps1_1 <- subset_taxa(ps0, !Kingdom %in% filterPhyla)
ps1_1
ps1_2 <- subset_taxa(ps1_1, !Phylum %in% filterPhyla)
ps1_2
ps1_3 <- subset_taxa(ps1_2, !Class %in% filterPhyla)
ps1_3
ps1_4 <- subset_taxa(ps1_3, !Order %in% filterPhyla)
ps1_4
ps1_5 <- subset_taxa(ps1_4, !Family %in% filterPhyla)
ps1_5
ps1_6 <- subset_taxa(ps1_5, !Genus %in% filterPhyla)
ps1_6


```

## Put best possible ID of the ASV in the name 
```{r}
#name ASV_1_xxx
sa <- ps1_6
 
for (i in 1:ntaxa(sa)){
  if (nchar(tax_table(sa)[i,6], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,6], "_sp.", sep = "")
  }
  else if (nchar(tax_table(sa)[i,5], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,5], sep = "")
  }
  else if (nchar(tax_table(sa)[i,4], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,4], sep = "")
  }
  else if (nchar(tax_table(sa)[i,3], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,3], sep = "")
  }
  else if (nchar(tax_table(sa)[i,2], keepNA = FALSE)>3){
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,2], sep = "")
  }
  else {
    taxa_names(sa)[i] = paste("ASV_", i, "_", tax_table(sa)[i,1], sep = "")
  }
}

tax_table(sa) <- cbind(tax_table(sa), taxa_names(sa))
colnames(tax_table(sa))[8] <- "ASV"

tax_table(sa)
```

## Barplot with agglomerate


```{r}
# Agglomerate on phylum level
psB_phylum <- tax_glom(ps1_6, taxrank = "Phylum")


# Make the samples relative
psB_phylum_rel <- transform_sample_counts(psB_phylum, function(sv) sv/sum(sv))


# Melt the dataset
B_phylum_rel <- speedyseq::psmelt(psB_phylum_rel)



plot_bar(psB_phylum_rel, fill = "Phylum") +
  aes(x = SampleID) +
  facet_grid(cols = vars(Responsible), scale = "free", space = "free_x") +
  guides(fill = guide_legend(ncol = 2)) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 10),
    legend.position = "right",
    panel.spacing = unit(1, "lines")
  ) +
  labs(x = "Sample", y = "Relative Abundance")


```


```{r}
# Order the phylum based on abundance for ggplot
## Summarize the data to calculate total abundance within each Timepoint and Phylum
ps_summary <- B_phylum_rel %>%
  group_by(Phylum, Responsible) %>%
  summarise(Abundance = mean(Abundance)) %>%
  ungroup() %>%
  arrange((Abundance))
```


```{r}
ggplot(ps_summary, aes(x = Responsible, y = Abundance, fill = Phylum)) + 
  geom_bar(stat = "identity", position = "stack") +
  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
   scale_y_continuous(labels = scales::percent_format()) +
  
  labs(y = "Relative abundance") 

```


## Beta-diversity

```{r}
#BETADIVERSITY ANALYSIS - ORDINATION (here, based on BRAY-CURTIS dissimilarity)

#ordination tout Type Bray}

# Here I make an ordination on the whole data set
# I did it on Bray-Curtis dissimilarity, but it is also possible to do it on the unifrac distance that takes the phylogeny into account

#To throw away empty samples, otherwise summ will nog work
sa_ra <- transform_sample_counts(sa, function(x){ x / sum(x)}) #na.rm = TRUE  
sa_ra_1 <- prune_samples(sample_sums(sa_ra) > 0, sa_ra)

theme_set(theme_bw())
ordu_sa_ra = ordinate(sa_ra_1 , "PCoA", "bray")

#plot
OrdiPlot_sa_ra = plot_ordination(sa_ra_1, ordu_sa_ra, color="Responsible", shape="Responsible")
OrdiPlot_sa_ra + 
  geom_point(size=5, stroke=1.5) + 
  coord_fixed(1/1) + 
  scale_shape_manual(values = c(16, 17, 15, 3, 7, 8, 9, 10, 4)) + 
  theme(
    axis.text = element_text(size=20),
    axis.title = element_text(size=20),
    legend.title = element_text(size=20),
    legend.text = element_text(size=20),
    legend.position = "bottom"
  ) +
  labs(color = "Responsible") +
  guides(color = guide_legend(ncol=2),shape = guide_legend(ncol=2))


```









##########################################################################################
######################################## EXTRA ###########################################
##########################################################################################


## Barplot with agglomerate

More information on [phyloseq barplots can be found here](https://joey711.github.io/phyloseq/plot_bar-examples.html)

In a first attempt to create a barplot, we will work on the phylum level and make this data relative.

```{r}
# Agglomerate on phylum level
psB_Class <- tax_glom(ps1_6, taxrank = "Class")


# Make the samples relative
psB_Class_rel <- transform_sample_counts(psB_Class, function(sv) sv/sum(sv))


# Melt the dataset
B_Class_rel <- speedyseq::psmelt(psB_Class_rel)


plot_bar(psB_Class_rel, fill = "Class") +
  aes(x = SampleID) +
  facet_grid(cols = vars(Sample_type), scale = "free", space = "free_x") +
  guides(fill = guide_legend(ncol = 4)) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 10),
    legend.position = "right",
    panel.spacing = unit(1, "lines")
  ) +
  labs(x = "Sample", y = "Relative Abundance")

```

```{r}
# Statistical analysis beta diversity

df = as(sample_data(sa_ra_1), "data.frame")
dist = phyloseq::distance(sa_ra_1, "bray")

#You can use the function "Adonis" or "Adonis2", with Adonis2 you can see R2 values
Adonis_total = adonis2(dist ~ Sample_type, df)
Adonis_total

```


# Unifrac

```{r}
#Weighted unifrac distance
wUF.ordu = ordinate(sa_ra_1, method="PCoA", distance="unifrac", weighted=TRUE)

plot_ordination(sa_ra_1, wUF.ordu, shape="Sample_type", color="Sample_type") + 
  ggtitle("Weighted UniFrac")+ geom_point(size = 4)

#unweighted unifrac distance
uwUF.ordu = ordinate(sa_ra_1, method="PCoA", distance="unifrac", weighted=FALSE)

plot_ordination(sa_ra_1, uwUF.ordu, shape="Sample_type", color="Sample_type") + 
  ggtitle("unWeighted UniFrac")+ geom_point(size = 4)
  guides(color=guide_legend(ncol=2), shape=guide_legend(ncol=2))
```



## alpha diversity
Important, perform this analyses on a count table or phyloseq object where only empty ASVs are removed. Do not remove singletons or doubletons.

package vegan
```{r echo = FALSE}
# Calculate diversity for all fields
df_divB <- data.frame(Diversity = vegan::diversity((otu_table(t(sa))), index = "shannon")) %>% cbind( sample_data(sa))
```

## alpha diversity
Important, perform this analyses on a count table or phyloseq object where only empty ASVs are removed. Do not remove singletons or doubletons.

```{r}
#To throw away empty samples, otherwise summ will nog work
sa_ra <- transform_sample_counts(sa, function(x){ x / sum(x)}) #na.rm = TRUE  
sa_ra_1 <- prune_samples(sample_sums(sa_ra) > 0, sa_ra)

samdf <- sample_data(sa_ra_1)
samdf

#ALpha diverstiy was caclulated per ASV instead of per sample
#To check this: 
dim(otu_table(sa_ra_1))
head(rownames(otu_table(sa_ra_1)))  # If these are ASV names, orientation is wrong
head(colnames(otu_table(sa_ra_1)))  # If these are sample names, orientation is correct

#To fix this
otu_table(sa_ra_1) <- t(otu_table(sa_ra_1))

#If you choose to do this part on a subset, adjust the div_samp, but also the samdf dataset!!

#Calculated diversity parameters, method from Borcard et al, numerical ecology in R pg 17)

N0 <- rowSums(otu_table(sa_ra_1) > 0)               #Species richness
H <- vegan::diversity(otu_table(sa_ra_1))           #Shannon entropy
N1 <- exp(H)                                           #Shannon diversity number
N2 <- vegan::diversity(otu_table(sa_ra_1), "inv")   #Simpson diversity number
J <- H/log(N0)                                         #Pielou eveness
E1 <- N1/N0                                            #Shannon evenness (Hill's ratio)
E2 <- N2/N0                                            #Simpson evenness (Hill's ratio)
div_samp <- data.frame(N0, H, N1, N2, E1, E2, J) #Put all the values in a data frame
rm(N0, H, N1, N2, E1, E2, J) #Remove the single values from the global environment

#Merge the diversity data with the sample metadata
div_samp <- merge(div_samp, samdf, by="row.names", all=TRUE)
row.names(div_samp) <- div_samp$Row.names #Reset the row names to the column Row.names
div_samp$Row.names <- NULL #Remove the column Row.names


summ <- ddply(div_samp, ~Sample_type, summarise, 
              meanN0 = mean(N0), sdN0 = sd(N0), seN0 = sd(N0) / sqrt(length(N0)),
              meanN1 = mean(N1),  sdN1 = sd(N1),  seN1 = sd(N1) / sqrt(length(N1))
)

ggplot (summ, aes(x=Sample_type, y=meanN0, fill=Sample_type)) + theme_light()+
  geom_bar( aes(x=Sample_type, y=meanN0, fill=Sample_type),stat='identity', 
            position = position_dodge(width=0.9, preserve="total"))+
  geom_errorbar( aes(ymax = meanN0 + sdN0, ymin=meanN0- sdN0), width=0.4, colour="darkgrey", 
                 alpha=0.9, linewidth=1.3,position = position_dodge(width=0.9, preserve="total")) +
  theme(axis.text.x = element_text(angle = 0, size=16))+
  labs(y="Species richness", x="Sample_type") +
  theme(axis.text=element_text(size=16), axis.title=element_text(size=20,face="bold")) +
  theme(legend.title=element_text(size=16), legend.text = element_text(size=14))+
  theme(strip.text = element_text(size=20))+
  theme(legend.position="bottom")
  #scale_fill_manual(values=c("#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"), name = "Location", labels = c("NC", "Bierbeek","Boutersem", "Herent","Lubbeek"))

ggplot (summ, aes(x=Sample_type, y=meanN1, fill=Sample_type)) + theme_light()+
  geom_bar( aes(x=Sample_type, y=meanN1, fill=Sample_type),stat='identity', 
            position = position_dodge(width=0.9, preserve="total"))+
  geom_errorbar( aes(ymax = meanN1 + sdN1, ymin=meanN1- sdN1), width=0.4, colour="darkgrey", 
                 alpha=0.9, linewidth=1.3,position = position_dodge(width=0.9, preserve="total")) +
  theme(axis.text.x = element_text(angle = 0, size=16))+
  labs(y="Shannon diversity", x="Sample_type") +
  theme(axis.text=element_text(size=16), axis.title=element_text(size=20,face="bold")) +
  theme(legend.title=element_text(size=16), legend.text = element_text(size=14))+
  theme(strip.text = element_text(size=20))+
  theme(legend.position="bottom")


#Micos niet meenemen in de vergelijking (nog geen Illumina data van)
summ_test <- subset(summ, !(Sample_type %in% c("Micos", "Michiel")))

#To change the order of the blocks made by facet grid
# Set custom order of Sample_type
summ_test$Sample_type <- factor(summ_test$Sample_type, levels = c("Soil", "Rhizosphere", "Endosphere", "Seedcoat", "Seed", "Mock"))

ggplot (summ_test, aes(x=Sample_type, y=meanN0, fill=Sample_type)) + theme_light()+
  geom_bar( aes(x=Sample_type, y=meanN0, fill=Sample_type),stat='identity', 
            position = position_dodge(width=0.9, preserve="total"))+
  geom_errorbar( aes(ymax = meanN0 + seN0, ymin=meanN0- seN0), width=0.4, colour="darkgrey", 
                 alpha=0.9, linewidth=1.3,position = position_dodge(width=0.9, preserve="total")) +
  theme(axis.text.x = element_text(angle = 0, size=16))+
  labs(y="Species richness", x="Sample type") +
  theme(axis.text=element_text(size=16), axis.title=element_text(size=20,face="bold")) +
  theme(legend.title=element_text(size=16), legend.text = element_text(size=14))+
  theme(strip.text = element_text(size=20))+
  theme(legend.position="bottom")

ggplot (summ_test, aes(x=Sample_type, y=meanN1, fill=Sample_type)) + theme_light()+
  geom_bar( aes(x=Sample_type, y=meanN1, fill=Sample_type),stat='identity', 
            position = position_dodge(width=0.9, preserve="total"))+
  geom_errorbar( aes(ymax = meanN1 + seN1, ymin=meanN1- seN1), width=0.4, colour="darkgrey", 
                 alpha=0.9, linewidth=1.3,position = position_dodge(width=0.9, preserve="total")) +
  theme(axis.text.x = element_text(angle = 0, size=16))+
  labs(y="Shannon diversity", x="Sample type") +
  theme(axis.text=element_text(size=16), axis.title=element_text(size=20,face="bold")) +
  theme(legend.title=element_text(size=16), legend.text = element_text(size=14))+
  theme(strip.text = element_text(size=20))+
  theme(legend.position="bottom")


ggplot(summ_test, aes(x = Sample_type, y = meanN0, fill = Sample_type)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymin = meanN0 - seN0, ymax = meanN0 + seN0), 
                position = position_dodge(width = 0.8), 
                width = 0.3, color = "gray30", linewidth = 1) +
  scale_fill_brewer(palette = "Set2") +  # Use a clean, colorblind-friendly palette
  labs(y = "Species richness", x = "Sample type", fill = "Sample type") +
  theme_light(base_size = 14) +
  theme(
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 18, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    strip.text = element_text(size = 18),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  )


ggplot(summ_test, aes(x = Sample_type, y = meanN1, fill = Sample_type)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymin = meanN1 - seN1, ymax = meanN1 + seN1), 
                position = position_dodge(width = 0.8), 
                width = 0.3, color = "gray30", linewidth = 1) +
  scale_fill_brewer(palette = "Set2") +  # Use a clean, colorblind-friendly palette
  labs(y = "Shannon diversity", x = "Sample type", fill = "Sample type") +
  theme_light(base_size = 14) +
  theme(
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 18, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    strip.text = element_text(size = 18),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  )


#Without Mock 
summ_test2 <- subset(summ, ! !(Sample_type %in% c("Micos", "Michiel", "Mock")))
#To change the order of the blocks made by facet grid
# Set custom order of Sample_type
summ_test2$Sample_type <- factor(summ_test2$Sample_type, levels = c("Soil", "Rhizosphere", "Endosphere", "Seedcoat", "Seed"))


ggplot (summ_test2, aes(x=Sample_type, y=meanN0, fill=Sample_type)) + theme_light()+
  geom_bar( aes(x=Sample_type, y=meanN0, fill=Sample_type),stat='identity', 
            position = position_dodge(width=0.9, preserve="total"))+
  geom_errorbar( aes(ymax = meanN0 + seN0, ymin=meanN0- seN0), width=0.4, colour="darkgrey", 
                 alpha=0.9, linewidth=1.3,position = position_dodge(width=0.9, preserve="total")) +
  theme(axis.text.x = element_text(angle = 0, size=16))+
  labs(y="Species richness", x="Sample type") +
  theme(axis.text=element_text(size=16), axis.title=element_text(size=20,face="bold")) +
  theme(legend.title=element_text(size=16), legend.text = element_text(size=14))+
  theme(strip.text = element_text(size=20))+
  theme(legend.position="bottom")

ggplot (summ_test2, aes(x=Sample_type, y=meanN1, fill=Sample_type)) + theme_light()+
  geom_bar( aes(x=Sample_type, y=meanN1, fill=Sample_type),stat='identity', 
            position = position_dodge(width=0.9, preserve="total"))+
  geom_errorbar( aes(ymax = meanN1 + seN1, ymin=meanN1- seN1), width=0.4, colour="darkgrey", 
                 alpha=0.9, linewidth=1.3,position = position_dodge(width=0.9, preserve="total")) +
  theme(axis.text.x = element_text(angle = 0, size=16))+
  labs(y="Shannon diversity", x="Sample type") +
  theme(axis.text=element_text(size=16), axis.title=element_text(size=20,face="bold")) +
  theme(legend.title=element_text(size=16), legend.text = element_text(size=14))+
  theme(strip.text = element_text(size=20))+
  theme(legend.position="bottom")

 
```






## Edge R

```{r}
###################################
####### EdgeR + figuren ###########
###################################


if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("edgeR")

install.packages("edgeR")
library(edgeR)

phyloseq_to_edgeR = function(physeq, group, method="RLE", ...){
  require("edgeR")
  require("phyloseq")
  # Enforce orientation.
  if( !taxa_are_rows(physeq) ){ physeq <- t(physeq) }
  x = as(otu_table(physeq), "matrix")
  # Add one to protect against overflow, log(0) issues.
  x = x + 1
  # Check `group` argument
  if( identical(all.equal(length(group), 1), TRUE) & nsamples(physeq) > 1 ){
    # Assume that group was a sample variable name (must be categorical)
    group = get_variable(physeq, group)
  }
  # Define gene annotations (`genes`) as tax_table
  taxonomy = tax_table(physeq, errorIfNULL=FALSE)
  if( !is.null(taxonomy) ){
    taxonomy = data.frame(as(taxonomy, "matrix"))
  } 
  # Now turn into a DGEList
  y = DGEList(counts=x, group=group, genes=taxonomy, remove.zeros = TRUE, ...)
  # Calculate the normalization factors
  z = calcNormFactors(y, method=method)
  # Check for division by zero inside `calcNormFactors`
  if( !all(is.finite(z$samples$norm.factors)) ){
    stop("Something wrong with edgeR::calcNormFactors on this data,
         non-finite $norm.factors, consider changing `method` argument")
  }
  # Estimate dispersions
  return(estimateTagwiseDisp(estimateCommonDisp(z)))
  }

```

```{r}
#Difference between seed and seedcoat
sa_Seeds <- subset_samples(sa, Compartment %in% c("seed", "coat"))

dge = phyloseq_to_edgeR(sa_Seeds, group="Compartment")
# Perform binary test
et = exactTest(dge)
# Extract values from test results
tt = topTags(et, n=nrow(dge$table), adjust.method="BH", sort.by="PValue")
res = tt@.Data[[1]]
alpha = 0.001
sigtab = res[(res$FDR < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(sa_Seeds)[rownames(sigtab), ], "matrix"))
dim(sigtab)
head(sigtab) #toont de OTUs die verschillend zijn.

install.packages("writexl")
library("writexl")
write_xlsx(sigtab,"S:/lm_micro2soil/x_personal_folders/1_Shira_Houwenhuyse/Matthijs_first_data/Sigtab_seed_vs_coat.xlsx")


theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
  scale_fill_brewer(palette = palname, ...)
}
sigtabgen = subset(sigtab, !is.na(Genus))
# Phylum order
x = tapply(sigtabgen$logFC, sigtabgen$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Phylum = factor(as.character(sigtabgen$Phylum), levels = names(x))
# Genus order
x = tapply(sigtabgen$logFC, sigtabgen$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Genus = factor(as.character(sigtabgen$Genus), levels = names(x))
ggplot(sigtabgen, aes(x = Genus, y = logFC, color = Phylum)) + geom_point(size=6) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5))


```


```{r}
#Difference between sterilisation methods within seed + coat

dge = phyloseq_to_edgeR(sa_Seeds, group="Sterile")
# Perform binary test
et = exactTest(dge)
# Extract values from test results
tt = topTags(et, n=nrow(dge$table), adjust.method="BH", sort.by="PValue")
res = tt@.Data[[1]]
alpha = 0.001
sigtab2 = res[(res$FDR < alpha), ]
sigtab2 = cbind(as(sigtab2, "data.frame"), as(tax_table(sa_Seeds)[rownames(sigtab2), ], "matrix"))
dim(sigtab2)
head(sigtab2) #toont de OTUs die verschillend zijn.


write_xlsx(sigtab2,"S:/lm_micro2soil/x_personal_folders/1_Shira_Houwenhuyse/Matthijs_first_data/Sigtab2_seed_sterile.xlsx")


theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
  scale_fill_brewer(palette = palname, ...)
}
sigtabgen = subset(sigtab, !is.na(Genus))
# Phylum order
x = tapply(sigtabgen$logFC, sigtabgen$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Phylum = factor(as.character(sigtabgen$Phylum), levels = names(x))
# Genus order
x = tapply(sigtabgen$logFC, sigtabgen$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Genus = factor(as.character(sigtabgen$Genus), levels = names(x))
ggplot(sigtabgen, aes(x = Genus, y = logFC, color = Phylum)) + geom_point(size=6) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5))


```


```{r}
#Interacties bekijken -> Interactie kolommen toevoegen!!
data_seeds <- sample_data(sa_Seeds)

#Aanpassen in metadata: 
CompxSterile <- paste(data_Seeds$Compartment, Metadata$Sterile, sep = "_")
#Aanpassen in phyloseq object 
sample_data(sa_Seeds)$CompxSterile <-  (sample_data(sa_Seeds)$Compartment, sample_data(sa_Seeds)$Sterile, sep = "_")


#Interactie microbiome stressor op enkel recipienten -> Sigtab4

dge = phyloseq_to_edgeR(sa_Seeds, sample_data(sa_Seeds)$CompXSterile)
# Perform binary test
et = exactTest(dge)
# Extract values from test results
tt = topTags(et, n=nrow(dge$table), adjust.method="BH", sort.by="PValue")
res = tt@.Data[[1]]
alpha = 0.01 #ALPHA VERHOOGT WANT GAF ANDERS GEEN RESULTS
sigtab3 = res[(res$FDR < alpha), ]
sigtab3 = cbind(as(sigtab3, "data.frame"), as(tax_table(sa_Seeds)[rownames(sigtab3), ], "matrix"))
dim(sigtab3)
head(sigtab3) #toont de OTUs die verschillend zijn.


write_xlsx(sigtab3,"S:/lm_micro2soil/x_personal_folders/1_Shira_Houwenhuyse/Matthijs_first_data/Sigtab3_Seeds_compartment_vs_sterile.xlsx")


theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
  scale_fill_brewer(palette = palname, ...)
}
sigtabgen = subset(sigtab3, !is.na(Genus))
# Phylum order
x = tapply(sigtabgen$logFC, sigtabgen$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Phylum = factor(as.character(sigtabgen$Phylum), levels = names(x))
# Genus order
x = tapply(sigtabgen$logFC, sigtabgen$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Genus = factor(as.character(sigtabgen$Genus), levels = names(x))
ggplot(sigtabgen, aes(x = Genus, y = logFC, color = Phylum)) + geom_point(size=6) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5))
```


```{r}
##########################################
####### EdgeR-FIGUREN van Lisa ###########
##########################################

#Create figure of significant families
#Volgende figuur zijn al mijn significante families die gevonden zijn uit EdgeR. 
#Ik ga hieronder stapsgewijs uitleggen hoe ik dat gedaan heb aan de hand van de dummie dataset 
#dat ik hier gebruik. Figuur zal dus beperkter zijn, maar principe is hetzelfde.

#{r, echo=FALSE, fig.width = 3, fig.height = 3, fig.align="center"}
#knitr::include_graphics("Example_Figure.png")



#Ik werk gemakkelijk met functies, zeker als ik een bepaalde figuur verschillende keren moet maken. 
#En van de zaken die ik doe als ik figuren maak voor een artikel is mijn lay-out vastleggen in alsvolgt:
#dit kan je dan toevoegen bij ggplot door __+ Publishable_theme()__ bij te voegen
#{r include = FALSE}
Publishable_theme <- function() {
  theme(# add axis lines
    axis.line.y = element_line(color = "darkgrey"),
    axis.line.x = element_line(color = "darkgrey"),
    # remove the background
    panel.background = element_blank(), 
    # Add the gridlines of the y-axis
    panel.grid.major.y = element_line(colour = "lightgrey", size = 0.2), 
    panel.grid.minor.y = element_line(colour = "lightgrey", size = 0.2), 
    # remove the vertical lines
    panel.grid.major.x = element_line(colour = "lightgrey", size = 0.2), 
    panel.grid.minor.x = element_line(colour = "lightgrey", size = 0.2), 
    # size of the titles
    axis.title = element_text(size = 8),
    axis.text = element_text(size = 8),
    plot.title = element_text(hjust = 0, size = 8, face="bold"),
    #axis.text.x = element_blank(),
    #remove background legend
    legend.key=element_blank()
    
  )
}

```


```{r}
## Stapsgewijs opbouw figuur

#Sigtab 1 staat voor vergelijking microbioom binnen recipients
Significant <- sigtab

# Step 1: Find the data that is relevant to plot. 
#Meaning collect only the information of the families that were significant.

tax_df <- as.data.frame(tax_table(sa_ra_Seeds)) # Extract taxonomy table as a data frame
taxa_to_keep <- rownames(tax_df)[tax_df$Family %in% Significant$Family] # Get taxa names that match the significant families
Relative_abund <- prune_taxa(taxa_to_keep, sa_ra_Seeds)# Subset the phyloseq object based on those taxa


otu_df <- as.data.frame(otu_table(Relative_abund)) # Extract the OTU table and convert it to a data frame
tax_df <- as.data.frame(tax_table(Relative_abund)) # Add taxonomy data
meta_df <- as.data.frame(sample_data(Relative_abund)) # Extract sample metadata

# Convert OTU table to long format (to allow grouping by factors)
library(tidyr)
otu_long <- otu_df %>%
  tibble::rownames_to_column("ASV") %>% 
  pivot_longer(-ASV, names_to = "Sample", values_to = "Abundance")

# Merge taxonomy info
otu_long <- merge(otu_long, tax_df, by.x = "ASV", by.y = "row.names")

# Merge with metadata
otu_long <- merge(otu_long, meta_df, by.x = "Sample", by.y = "row.names")

# Now, summarize the data
Summary.sign <- otu_long %>%
  dplyr::group_by(Phylum, Family, Compartment) %>%
  dplyr::summarize(
    n = n(),
    Mean = mean(Abundance), 
    SD = sd(Abundance),
    SE = SD / sqrt(n),
    CI.lower = Mean - 1.96 * SE, 
    CI.upper = Mean + 1.96 * SE
  ) %>%
  dplyr::mutate_if(is.numeric, ~round(., 4))

# View the summarized data
print(Summary.sign)


# Step 3: If you want to have the families ordered from low to high mean relative abundance and 
#also according to a decrease or increase you can do the following step:

# Divide in two groups: higher or lower abundant than soilA
x <- tapply(Significant$logFC, Significant$Family, function(x) max(x))
x <- sort(x, TRUE) # order from low to high therefore FALSE
group1 <- x[x<0] # Decrease
group2 <- x[x>0] # Increase

# Order within group on rel. abundance
Summary.sign$Group <- with(Summary.sign, ifelse(Family %in% names(group1), "Group1", "Group2"))

# Get unique families                    
y <- as.character(unique(arrange(Summary.sign,Group,-Mean)$Family ))

#Order from low abundant to high abundant rel.abundance
Summary.sign[,"Family"] <- factor(as.character(droplevels(as.factor(Summary.sign$Family))), levels = (y))



# Step 4: Finally make the plot
## x = Interaction will give you the Phylum and Family names.

ggplot(Summary.sign, aes(y = Mean, x = interaction(Phylum, Family, sep=": "), color = unlist(Summary.sign["Compartment"]), fill = unlist(Summary.sign["Compartment"]))) +
  coord_flip() +
  geom_point(linewidth = 1, position = position_dodge(0.4)) +
  geom_errorbar(aes(ymin = CI.lower, ymax = CI.upper), position = position_dodge(0.4)) +
  Publishable_theme() +
  theme(axis.title = element_text(face = "bold"), 
        legend.title = element_blank()) + 
  xlab("") +
  ylab("Relative abundance") +
  # scale_fill_manual(values = myFill) +
  # scale_colour_manual(values =  whichColour) +
  ggtitle("Title")
```



```{r}
#Interactie -> figuur
#Sigtab 4 staat voor interactie microbiome x stressor binnen recipients
Significant <- sigtab3

sample_data(sa_ra_Seeds)$CompxSterile <- paste(sample_data(sa_ra_Seeds)$Compartment, 
                                               sample_data(sa_ra_Seeds)$Sterile, 
                                               sep = "_")

tax_df <- as.data.frame(tax_table(sa_ra_Seeds)) # Extract taxonomy table as a data frame
taxa_to_keep <- rownames(tax_df)[tax_df$Family %in% Significant$Family] # Get taxa names that match the significant families
Relative_abund <- prune_taxa(taxa_to_keep, sa_ra_Seeds)# Subset the phyloseq object based on those taxa


otu_df <- as.data.frame(otu_table(Relative_abund)) # Extract the OTU table and convert it to a data frame
tax_df <- as.data.frame(tax_table(Relative_abund)) # Add taxonomy data
meta_df <- as.data.frame(sample_data(Relative_abund)) # Extract sample metadata

# Convert OTU table to long format (to allow grouping by factors)
library(tidyr)
otu_long <- otu_df %>%
  tibble::rownames_to_column("ASV") %>% 
  pivot_longer(-ASV, names_to = "Sample", values_to = "Abundance")

# Merge taxonomy info
otu_long <- merge(otu_long, tax_df, by.x = "ASV", by.y = "row.names")

# Merge with metadata
otu_long <- merge(otu_long, meta_df, by.x = "Sample", by.y = "row.names")



summary(otu_long$Abundance) #Has very low abundances -> set treshold lower
otu_long_filtered <- otu_long %>% filter(Abundance > 1e-6)  # Less strict filter



# Now, summarize the data
Summary.sign <- otu_long_filtered %>%
  dplyr::group_by(Phylum, Family, CompxSterile, Compartment, Sterile) %>%
  dplyr::summarize(
    n = n(),
    Mean = mean(Abundance), 
    SD = sd(Abundance),
    SE = SD / sqrt(n),
    CI.lower = Mean - 1.96 * SE, 
    CI.upper = Mean + 1.96 * SE
  ) %>%
  dplyr::mutate_if(is.numeric, ~round(., 4))

# View the summarized data
print(Summary.sign)



# Step 3: If you want to have the families ordered from low to high mean relative abundance and 
#also according to a decrease or increase you can do the following step:

# Divide in two groups: higher or lower abundant than soilA
x <- tapply(Significant$logFC, Significant$Family, function(x) max(x))
x <- sort(x, TRUE) # order from low to high therefore FALSE
group1 <- x[x<0] # Decrease
group2 <- x[x>0] # Increase

# Order within group on rel. abundance
Summary.sign$Group <- with(Summary.sign, ifelse(Family %in% names(group1), "Group1", "Group2"))

# Get unique families                    
y <- as.character(unique(arrange(Summary.sign,Group,-Mean)$Family ))

#Order from low abundant to high abundant rel.abundance
Summary.sign[,"Family"] <- factor(as.character(droplevels(as.factor(Summary.sign$Family))), levels = (y))



# Step 4: Finally make the plot
## x = Interaction will give you the Phylum and Family names.

ggplot(Summary.sign, aes(y = Mean, x = interaction(Phylum, Family, sep=": "), color = unlist(Summary.sign["CompxSterile"]), fill = unlist(Summary.sign["CompxSterile"]))) +
  coord_flip() +
  geom_point(size = 1, position = position_dodge(0.4)) +
  geom_errorbar(aes(ymin = CI.lower, ymax = CI.upper), position = position_dodge(0.4)) +
  Publishable_theme() +
  theme(axis.title = element_text(face = "bold"), 
        legend.title = element_blank()) + 
  xlab("") +
  ylab("Relative abundance") +
  # scale_fill_manual(values = myFill) +
  # scale_colour_manual(values =  whichColour) +
  ggtitle("Title")

#Splits per compartment
ggplot(Summary.sign, aes(y = Mean, x = interaction(Phylum, Family, sep=": "), color = unlist(Summary.sign["CompxSterile"]), fill = unlist(Summary.sign["CompxSterile"]))) +
  coord_flip() +
  geom_point(size = 1, position = position_dodge(0.4)) +
  geom_errorbar(aes(ymin = CI.lower, ymax = CI.upper), position = position_dodge(0.4)) +
  Publishable_theme() +
  theme(axis.title = element_text(face = "bold"), 
        legend.title = element_blank()) + 
  xlab("") +
  ylab("Relative abundance") +
  # scale_fill_manual(values = myFill) +
  # scale_colour_manual(values =  whichColour) +
  ggtitle("Compartment x Sterile")+
  facet_wrap(~Compartment)


#Splits per Sterilisation method
ggplot(Summary.sign, aes(y = Mean, x = interaction(Phylum, Family, sep=": "), color = unlist(Summary.sign["CompxSterile"]), fill = unlist(Summary.sign["CompxSterile"]))) +
  coord_flip() +
  geom_point(size = 1, position = position_dodge(0.4)) +
  geom_errorbar(aes(ymin = CI.lower, ymax = CI.upper), position = position_dodge(0.4)) +
  Publishable_theme() +
  theme(axis.title = element_text(face = "bold"), 
        legend.title = element_blank()) + 
  xlab("") +
  ylab("Relative abundance") +
  # scale_fill_manual(values = myFill) +
  # scale_colour_manual(values =  whichColour) +
  ggtitle("Compartment x Sterile")+
  facet_wrap(~Sterile)

```

## ANCOM-BC2 (differntial abundance analyis)
https://www.nature.com/articles/s41467-022-28034-z

Following: https://www.bioconductor.org/packages/release/bioc/vignettes/ANCOMBC/inst/doc/ANCOMBC2.html 


```{r}
# Download package

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("ANCOMBC")

# Load package
library(ANCOMBC)
```

```{r}
#Run ancombc2 function using the phyloseq object

#Only on seed data to compare sterilisation methods

set.seed(123)
# It should be noted that we have set the number of bootstrap samples (B) equal 
# to 10 in the 'trend_control' function for computational expediency. 
# However, it is recommended that users utilize the default value of B, 
# which is 100, or larger values for optimal performance.

d<-sample_data(sa)
table(sample_data(sa)$Compartment)
table(sample_data(sa)$Location)

output = ancombc2(data = sa_Seeds, tax_level = "Family",
                   fix_formula = "Compartment + Sterile",
                   group = "Compartment",  
                   p_adj_method = "holm",
                   prv_cut = 0.10, lib_cut = 0, 
                   struc_zero = FALSE, 
                   neg_lb = FALSE,
                   alpha = 0.05, global = TRUE)



```


```{r}
#If you want to look at interaction, use * (eg Compartment * Sterile) in "fix_formula
#Also in "group" you can put interactions

#Example
set.seed(123)
# Ensure Compartment and Sterile are factors in metadata
sample_data(sa_Seeds)$Compartment <- as.factor(sample_data(sa_Seeds)$Compartment)
sample_data(sa_Seeds)$Sterile <- as.factor(sample_data(sa_Seeds)$Sterile)
sample_data(sa_Seeds)$CompXSterile <- as.factor(sample_data(sa_Seeds)$CompXSterile)


# Run the analysis with the correct formula
output_interact = ancombc2(data = sa_Seeds, tax_level = "Family",
                            fix_formula = "CompXSterile", rand_formula = NULL,
                            p_adj_method = "holm", pseudo_sens = TRUE,
                            prv_cut = 0.05, lib_cut = 500, s0_perc = 0.05,  # Adjusted filters
                            group = "CompXSterile", struc_zero = FALSE, neg_lb = TRUE,
                            alpha = 0.05, n_cl = 2, verbose = TRUE)

#sommige categorin zijn te klein, dan werkt deze methode niet. 
#Die stalen er uit zwieren
sa_Seeds_filtered <- subset_samples(sa_Seeds, !(CompXSterile %in% c("coat_Bleach", "coat_EtOH", "seed_Bleach", "seed_No"))) 
#Als ze alle 4 verwijderd worden blijft er niets meer over
sa_Seeds_filtered <- subset_samples(sa_Seeds, !(CompXSterile %in% c("coat_Bleach", "coat_EtOH")))

table(sample_data(sa_Seeds)$CompXSterile)

table(sample_data(sa_Seeds_filtered)$CompXSterile)

sa_Seeds_filtered <- subset_samples(sa_Seeds, !(CompXSterile %in% c("coat_Bleach", "coat_EtOH", "seed_EtOH")))


#########################################################
#METHODE WERKT NIET OP DEZE KLEINE DATA SET (enkel zaden)
# MINSTENS 5 STALEN NODIG [DENK IK]
#########################################################

# Now run the analysis on the filtered dataset
output_interact = ancombc2(data = sa_Seeds_filtered, tax_level = "Family",
                            fix_formula = "CompXSterile", rand_formula = NULL,
                            p_adj_method = "holm", pseudo_sens = TRUE,
                            prv_cut = 0.05, lib_cut = 500, s0_perc = 0.05,
                            group = "CompXSterile", struc_zero = FALSE, neg_lb = TRUE,
                            alpha = 0.05, n_cl = 2, verbose = TRUE)



head(output_interact$res) %>%
    dplyr::select(starts_with("lfc_Compartment")) %>%
    mutate_if(is.numeric, function(x) round(x, 2)) %>%
    datatable(caption = "Example of including interaction terms")
```

```{r}
# Structural zeros (taxon presence/absence)
install.packages("DT")
library(DT)


tab_zero = output$zero_ind
tab_zero %>%
    datatable(caption = "The detection of structural zeros")
```

# ANCOM-BC2 primary analysis
The primary output of the ANCOM-BC2 methodology identifies taxa with differential abundance based on the chosen covariate. The results include: 1) log fold changes, 2) standard errors, 3) test statistics, 4) p-values, 5) adjusted p-values, 6) indicators denoting whether the taxon is differentially abundant (TRUE) or not (FALSE), and 7) indicators denoting whether the taxon passed the sensitivity analysis (TRUE) or not (FALSE).

```{r}
res_prim = output$res

```

```{r}
#waterfall plot
df_comp = res_prim %>%
    dplyr::select(taxon, ends_with("Compartment")) 
df_fig_comp = df_comp %>%
    dplyr::filter(diff_comp == 1) %>% 
    dplyr::arrange(desc(lfc_comp)) %>%
    dplyr::mutate(direct = ifelse(lfc_comp > 0, "Positive LFC", "Negative LFC"),
                  color = ifelse(passed_ss_comp == 1, "aquamarine3", "black"))
df_fig_comp$taxon = factor(df_fig_comp$taxon, levels = df_fig_comp$taxon)
df_fig_comp$direct = factor(df_fig_comp$direct, 
                           levels = c("Positive LFC", "Negative LFC"))


fig_comp = df_fig_comp %>%
    ggplot(aes(x = taxon, y = lfc_comp, fill = direct)) + 
    geom_bar(stat = "identity", width = 0.7, color = "black", 
             position = position_dodge(width = 0.4)) +
    geom_errorbar(aes(ymin = lfc_comp - se_comp, ymax = lfc_comp + se_comp), 
                  width = 0.2, position = position_dodge(0.05), color = "black") + 
    labs(x = NULL, y = "Log fold change", 
         title = "Log fold changes as one unit increase of Compartment") + 
    scale_fill_discrete(name = NULL) +
    scale_color_discrete(name = NULL) +
    theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5),
          panel.grid.minor.y = element_blank(),
          axis.text.x = element_text(angle = 60, hjust = 1,
                                     color = df_fig_comp$color))
fig_comp
```

```{r}
# heatmap

df_bmi = res_prim %>%
    dplyr::select(taxon, contains("bmi")) 
df_fig_bmi1 = df_bmi %>%
    dplyr::filter(diff_bmilean == 1 | 
                    diff_bmioverweight == 1) %>%
    dplyr::mutate(lfc1 = ifelse(diff_bmioverweight == 1, 
                                round(lfc_bmioverweight, 2), 0),
                  lfc2 = ifelse(diff_bmilean == 1, 
                                round(lfc_bmilean, 2), 0)) %>%
    tidyr::pivot_longer(cols = lfc1:lfc2, 
                        names_to = "group", values_to = "value") %>%
    dplyr::arrange(taxon)

df_fig_bmi2 = df_bmi %>%
    dplyr::filter(diff_bmilean == 1 | 
                    diff_bmioverweight == 1) %>%
    dplyr::mutate(lfc1 = ifelse(passed_ss_bmioverweight == 1 & diff_bmioverweight == 1, 
                                "aquamarine3", "black"),
                  lfc2 = ifelse(passed_ss_bmilean == 1 & diff_bmilean == 1, 
                                "aquamarine3", "black")) %>%
    tidyr::pivot_longer(cols = lfc1:lfc2, 
                        names_to = "group", values_to = "color") %>%
    dplyr::arrange(taxon)

df_fig_bmi = df_fig_bmi1 %>%
    dplyr::left_join(df_fig_bmi2, by = c("taxon", "group"))

df_fig_bmi$group = recode(df_fig_bmi$group, 
                          `lfc1` = "Overweight - Obese",
                          `lfc2` = "Lean - Obese")
df_fig_bmi$group = factor(df_fig_bmi$group, 
                          levels = c("Overweight - Obese",
                                     "Lean - Obese"))
  
lo = floor(min(df_fig_bmi$value))
up = ceiling(max(df_fig_bmi$value))
mid = (lo + up)/2
fig_bmi = df_fig_bmi %>%
  ggplot(aes(x = group, y = taxon, fill = value)) + 
  geom_tile(color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       na.value = "white", midpoint = mid, limit = c(lo, up),
                       name = NULL) +
  geom_text(aes(group, taxon, label = value, color = color), size = 4) +
  scale_color_identity(guide = "none") +
  labs(x = NULL, y = NULL, title = "Log fold changes as compared to obese subjects") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
fig_bmi
```

#ANCOM-BC2 global test
The primary goal of the ANCOM-BC2 global test is to discern taxa that demonstrate differential abundance between a minimum of two groups when analyzing three or more experimental groups.

The results encompass: 1) test statistics, 2) p-values, 3) adjusted p-values, 4) indicators denoting whether the taxon is differentially abundant (TRUE) or not (FALSE), and 5) indicators denoting whether the taxon passed the sensitivity analysis (TRUE) or not (FALSE).

In the subsequent heatmap, each cell represents a log fold-change (in natural log) value. Taxa marked in green have successfully passed the sensitivity analysis for pseudo-count addition.

```{r}
res_global = output$res_global
df_bmi = res_prim %>%
    dplyr::select(taxon, contains("bmi")) 
df_fig_global = df_bmi %>%
    dplyr::left_join(res_global %>%
                       dplyr::transmute(taxon, 
                                        diff_bmi = diff_abn, 
                                        passed_ss = passed_ss)) %>%
    dplyr::filter(diff_bmi == 1) %>%
    dplyr::mutate(lfc_overweight = lfc_bmioverweight,
                  lfc_lean = lfc_bmilean,
                  color = ifelse(passed_ss == 1, "aquamarine3", "black")) %>%
    dplyr::transmute(taxon,
                     `Overweight - Obese` = round(lfc_overweight, 2),
                     `Lean - Obese` = round(lfc_lean, 2), 
                     color = color) %>%
    tidyr::pivot_longer(cols = `Overweight - Obese`:`Lean - Obese`, 
                        names_to = "group", values_to = "value") %>%
    dplyr::arrange(taxon)

df_fig_global$group = factor(df_fig_global$group, 
                             levels = c("Overweight - Obese",
                                        "Lean - Obese"))
  
lo = floor(min(df_fig_global$value))
up = ceiling(max(df_fig_global$value))
mid = (lo + up)/2
fig_global = df_fig_global %>%
  ggplot(aes(x = group, y = taxon, fill = value)) + 
  geom_tile(color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       na.value = "white", midpoint = mid, limit = c(lo, up),
                       name = NULL) +
  geom_text(aes(group, taxon, label = value), color = "black", size = 4) +
  labs(x = NULL, y = NULL, title = "Log fold changes for globally significant taxa") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_text(color = df_fig_global %>%
                                       dplyr::distinct(taxon, color) %>%
                                       .$color))
fig_global

```
# ANCOM-BC2 multiple pairwise comparisons
The ANCOM-BC2 methodology for multiple pairwise comparisons is designed to identify taxa that exhibit differential abundance between any two groups within a set of three or more experimental groups, all while maintaining control over the mdFDR.

For instance, in our analysis focusing on the categories lean, overweight, and obese, the output provides: 1) log fold changes, 2) standard errors, 3) test statistics, 4) p-values, 5) adjusted p-values, 6) indicators denoting whether the taxon is differentially abundant (TRUE) or not (FALSE), and 7) indicators denoting whether the taxon passed the sensitivity analysis (TRUE) or not (FALSE).

In the subsequent heatmap, each cell represents a log fold-change (in natural log) value. Entries highlighted in green have successfully passed the sensitivity analysis for pseudo-count addition.
```{r}
res_pair = output$res_pair

df_fig_pair1 = res_pair %>%
    dplyr::filter(diff_bmioverweight == 1 |
                      diff_bmilean == 1 | 
                      diff_bmilean_bmioverweight == 1) %>%
    dplyr::mutate(lfc1 = ifelse(diff_bmioverweight == 1, 
                                round(lfc_bmioverweight, 2), 0),
                  lfc2 = ifelse(diff_bmilean == 1, 
                                round(lfc_bmilean, 2), 0),
                  lfc3 = ifelse(diff_bmilean_bmioverweight == 1, 
                                round(lfc_bmilean_bmioverweight, 2), 0)) %>%
    tidyr::pivot_longer(cols = lfc1:lfc3, 
                        names_to = "group", values_to = "value") %>%
    dplyr::arrange(taxon)

df_fig_pair2 = res_pair %>%
    dplyr::filter(diff_bmioverweight == 1 |
                      diff_bmilean == 1 | 
                      diff_bmilean_bmioverweight == 1) %>%
    dplyr::mutate(lfc1 = ifelse(passed_ss_bmioverweight == 1 & diff_bmioverweight == 1, 
                                "aquamarine3", "black"),
                  lfc2 = ifelse(passed_ss_bmilean == 1 & diff_bmilean == 1, 
                                "aquamarine3", "black"),
                  lfc3 = ifelse(passed_ss_bmilean_bmioverweight == 1 & diff_bmilean_bmioverweight == 1, 
                                "aquamarine3", "black")) %>%
    tidyr::pivot_longer(cols = lfc1:lfc3, 
                        names_to = "group", values_to = "color") %>%
    dplyr::arrange(taxon)

df_fig_pair = df_fig_pair1 %>%
    dplyr::left_join(df_fig_pair2, by = c("taxon", "group"))

df_fig_pair$group = recode(df_fig_pair$group, 
                          `lfc1` = "Overweight - Obese",
                          `lfc2` = "Lean - Obese",
                          `lfc3` = "Lean - Overweight")
df_fig_pair$group = factor(df_fig_pair$group, 
                          levels = c("Overweight - Obese",
                                     "Lean - Obese", 
                                     "Lean - Overweight"))

lo = floor(min(df_fig_pair$value))
up = ceiling(max(df_fig_pair$value))
mid = (lo + up)/2
fig_pair = df_fig_pair %>%
    ggplot(aes(x = group, y = taxon, fill = value)) + 
    geom_tile(color = "black") +
    scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                         na.value = "white", midpoint = mid, limit = c(lo, up),
                         name = NULL) +
    geom_text(aes(group, taxon, label = value, color = color), size = 4) +
    scale_color_identity(guide = FALSE) +
    labs(x = NULL, y = NULL, title = "Log fold changes as compared to obese subjects") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5))
fig_pair

```

```{r}


```


## Rarifaction

```{r}
#rarefaction curve om te kijken of we de diversity hebben gedekt
library(vegan)
ps1_6 <- prune_samples(sample_sums(ps1_6) > 0, ps1_6)
otu_mat <- as.matrix(as.data.frame(otu_table(ps1_6)))
rarecurve(otu_mat, step = 20, col = "blue", label = FALSE, 
          xlab = "# reads", ylab = "ASVs", xlim = c(0, 5000), minsize = 2)


### Check number of reads per sample, determine treshhold
sample_sums(ps1_6)
min(sample_sums(ps1_6))  
max(sample_sums(ps1_6))
mean(sample_sums(ps1_6))
sum(sample_sums(ps1_6))

#Here rarified on 1000 reads per sample
ps_rar <- ps1_6
ps_rar <- prune_samples(sample_sums(ps_rar)>1e3, ps_rar) 
ps_rar <- rarefy_even_depth(ps_rar, sample.size = min(sample_sums(ps_rar)), rngseed = 123, replace = FALSE) 
ps_rar <- transform_sample_counts(ps_rar, function(x) x / sum(x))
#ps_rar <- tip_glom(ps_rar, h = 0.1)
ps_rar <- filter_taxa(ps_rar, function(x) mean(x) > 1e-5, TRUE)
ps_rar


#Change the name of the taxa to "OTU number + highest assigned taxonomy""

#rename taxa}
sa_rar <- ps_rar

for (i in 1:ntaxa(sa_rar)){
  if (nchar(tax_table(sa_rar)[i,6], keepNA = FALSE)>3){
    taxa_names(sa_rar)[i] = paste("ASV_", i, "_", tax_table(sa_rar)[i,6], "_sp.", sep = "")
  }
  else if (nchar(tax_table(sa_rar)[i,5], keepNA = FALSE)>3){
    taxa_names(sa_rar)[i] = paste("ASV_", i, "_", tax_table(sa_rar)[i,5], sep = "")
  }
  else if (nchar(tax_table(sa_rar)[i,4], keepNA = FALSE)>3){
    taxa_names(sa_rar)[i] = paste("ASV_", i, "_", tax_table(sa_rar)[i,4], sep = "")
  }
  else if (nchar(tax_table(sa_rar)[i,3], keepNA = FALSE)>3){
    taxa_names(sa_rar)[i] = paste("ASV_", i, "_", tax_table(sa_rar)[i,3], sep = "")
  }
  else if (nchar(tax_table(sa_rar)[i,2], keepNA = FALSE)>3){
    taxa_names(sa_rar)[i] = paste("ASV_", i, "_", tax_table(sa_rar)[i,2], sep = "")
  }
  else {
    taxa_names(sa_rar)[i] = paste("ASV_", i, "_", tax_table(sa_rar)[i,1], sep = "")
  }
}


#Add extra column with otu numbers to tax_table

tax_table(sa_rar) <- cbind(tax_table(sa_rar), taxa_names(sa_rar))
colnames(tax_table(sa_rar))[7] <- "ASV"


#calculate relative abundances 
#calculate relative abundances sa_ra}
#To correct for variation in the number of reads, better to work on relative abundance

sa_ra_rar <- transform_sample_counts(sa_rar, function(x){ x / sum(x)}) #na.rm = TRUE   #na.rm = add true to remove NA's
sum(is.na(otu_table(sa_ra_rar))) #to check if there are NA's -> =0, so no NA

```

```{r}
#Only seed and seedcoat -> ONLY 4 SAMPLES REMAIN !!!
sa_ra_rar_1 <- prune_samples(sample_sums(sa_ra_rar) > 0, sa_ra_rar)
sa_ra_rar_Seeds <- subset_samples(sa_ra_rar_1, Compartment %in% c("seed", "coat"))

otu_table(sa_ra_rar_Seeds) <- t(otu_table(sa_ra_rar_Seeds))

samdf_rar_Seeds <- sample_data(sa_ra_rar_Seeds)
samdf_rar_Seeds


#If you choose to do this part on a subset, adjust the div_samp, but also the samdf dataset!!

#Calculated diversity parameters, method from Borcard et al, numerical ecology in R pg 17)

N0 <- rowSums(otu_table(sa_ra_rar_Seeds) > 0)               #Species richness
H <- vegan::diversity(otu_table(sa_ra_rar_Seeds))           #Shannon entropy
N1 <- exp(H)                                           #Shannon diversity number
N2 <- vegan::diversity(otu_table(sa_ra_rar_Seeds), "inv")   #Simpson diversity number
J <- H/log(N0)                                         #Pielou eveness
E1 <- N1/N0                                            #Shannon evenness (Hill's ratio)
E2 <- N2/N0                                            #Simpson evenness (Hill's ratio)
div_samp_rar_Seeds <- data.frame(N0, H, N1, N2, E1, E2, J) #Put all the values in a data frame
rm(N0, H, N1, N2, E1, E2, J) #Remove the single values from the global environment

#Merge the diversity data with the sample metadata
div_samp_rar_Seeds <- merge(div_samp_rar_Seeds, samdf_rar_Seeds, by="row.names", all=TRUE)
row.names(div_samp_rar_Seeds) <- div_samp_rar_Seeds$Row.names #Reset the row names to the column Row.names
div_samp_rar_Seeds$Row.names <- NULL #Remove the column Row.names

summ_rar_Seeds <- ddply(div_samp_rar_Seeds, ~Compartment+Sterile+Replica, summarise, 
                 meanN0 = mean(N0), sdN0 = sd(N0),
                 meanN1 = mean(N1), sdN1 = sd(N1)
)

ggplot (summ_rar_Seeds, aes(x=Compartment, y=meanN1, fill=Sterile)) + theme_light()+
  geom_bar( aes(x=Compartment, y=meanN1, fill=Sterile),stat='identity', 
            position = position_dodge(width=0.9, preserve="total"))+
  geom_errorbar( aes(ymax = meanN1 + sdN1, ymin=meanN1- sdN1), width=0.4, colour="darkgrey", 
                 alpha=0.9, linewidth=1.3,position = position_dodge(width=0.9, preserve="total")) +
  theme(axis.text.x = element_text(angle = 0, size=16))+
  labs(y="Shannon diversity", x="Compartment") +
  theme(axis.text=element_text(size=16), axis.title=element_text(size=20,face="bold")) +
  theme(legend.title=element_text(size=16), legend.text = element_text(size=14))+
  theme(strip.text = element_text(size=20))+
  theme(legend.position="bottom")+
  scale_fill_manual(values=c("#1f77b4", "#ff7f0e", "#2ca02c"), name = "Sterile", labels = c("Bleach", "EtOH", "Not"))


```



##############################
## From Lisa not tested yet ##
##############################

```{r}
# Create a boxplot for the diversity
## Only on part Preincubation
ggplot(df_divB, 
       aes(x = Compartment, y = Diversity, 
           colour = Compartment, 
           fill = Compartment)) +
  

   geom_boxplot(alpha = 0.5, outlier.shape = 16, outlier.colour = "black", outlier.alpha = 1) + 
   geom_jitter(width = 0.15) +
  
  # Set lay out of the graph
  xlab("") +
  ylim(c(0,8)) +
  ggtitle("Bacterial diversity")
```

## Beta diversity

### Permanova

_Background_
More information can be found in the paper of [Anderson et al., 2017](https://onlinelibrary.wiley.com/doi/full/10.1002/9781118445112.stat07841)

**What is PERMANOVA**  
`PERMANOVA`: Permutational multivariate analysis of variance using distance matrices. In this case Bray-Curtis matrix. 

**Assumptions**  
The `PERMANOVA`:  

- does not make explicit assumptions regarding either the distributions of original variables in Y or the distributions of dissimilarities in D.  
- is **very robust** to the heterogeneity of mulitivariate dispersions and is not sensitive to differences in correlation structure (shape) among groups.
- is insensitive to multicollinearity and  
- is insensitive to many zeroes. 
- is sensitive for an unbalanced design. This is not the case for this experiment.  


**Important**  

- This permanova is done on the preincubation part of the experiment, therefore we will subset the data.  
- Permanova is on dissimilarity matrices of **relative counts on ASV level**! as it is necessary to account for the sequencing depth. 
- We will use the function `set.seed()` to always have the same output.  
- We do not apply a blocking term in this model, as this part of the experiment was without blocks.  
- We have chosen to work with 9999 permutations, following the example of Anderson et al., 2017. 


**How will we proceed?**  

- With PERMANOVA the null hypothesis is:  

$H_0$ there is no differences in the group centroids of the compartments.  

If there is a statistically significant output, then we can believe that there are differences between our compartments. However, difference might also be caused because the inter-group variance is not equal. 
- Therefore, we will run the `betadisp()` function to evaluate if there is indeed unequal variances amongst the groups.  

$H_0$ = dispersions are homogeneous.  

If we get a significant result, we have identified a situation where the dispersion (variance) within a group is distinct from the other groups. 
To be sure of the output, the samples can be plotted with 95% confidence intervals. If the confidence ellipses don't overlap, it indicates that the centroids can be considered statisticaly different. 

```{r}
df_metadata_psB <- sample_data(psB_MVH)
```


We use the package adonis2 to calculate the permanova. In this specific example we use a bray-curtis matrix.


```{r}
# Set seed as this is a permutation.
set.seed(124)

permanova <- adonis2(t(otu_table(psBRel)) ~ 
                       df_metadata_psB$Compartment,
                     permutations = 999, method = "bray")
permanova
```

**Interpretation permanova**:  



```{r}
distance_psB <- vegdist(t(otu_table(psBRel)), method = "bray", na.rm = TRUE)

# Check homogeneity of variances
homogen <- betadisper(d = distance_psB, df_metadata_psB$Compartment)
anova(homogen)
```

**Interpretation betadisper**  
The output of the betadisper function is significant (p value = `r anova(homogen)$'Pr(>F)'[1]`) indicating that the assumption of equal variances is not fulfilled.  

```{r}
# Visualize the betadisper output
homogen.output <- data.frame("group" = homogen$group, distances = homogen$distances)

max(homogen.output$distances)

# Plot
ggplot(homogen.output, aes(x = homogen$group, y = homogen$distances, col = group)) + geom_boxplot() +
  xlab("Soil and treatment") +
  ylab("Distances to centroid") +
  ggtitle("Betadisper output")
```

### PCoA

```{r echo = FALSE}
# omit bad samples
otu_table_clean <- na.omit(otu_table(psBRel))  # Remove any rows with NAs

# Calculate ordination
pcoa.ord <- ordinate(psBRel, method = "PCoA", distance = "bray", na.rm = TRUE)

# Plot ordination
p <- plot_ordination(psBRel, 
                     pcoa.ord, 
                     color = "Compartment") +
  
 # stat_ellipse(aes(group = Compartment)) +
  
  geom_point(size = 3) + 
  
  # Set theme
  theme(axis.text = element_text(size = 10),
         axis.title = element_text(size = 12)) +
    
  labs("Sample type") 
# Remove layer of plot_ordination 
p$layers <- p$layers[-1]
p

# Save plot
# ggsave("Output/Bacteria/Bacteria_Preincubation_PcoA_ASV.png", width = 4.5, height = 3)
```

